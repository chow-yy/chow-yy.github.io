<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Intro to FHE â€” Interactive Tutorial</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root{--bg:#f9fafb;--card:#ffffff;--muted:#4b5563;--accent:#0284c7}
    body{font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#f0f9ff 0%,#ffffff 100%);color:#111827;margin:0;padding:32px}
    .container{max-width:980px;margin:0 auto}
    header{display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:28px}
    h2,h3,h4{scroll-margin-top:80px}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    p.lead{color:var(--muted);margin-top:8px}
    .card{background:var(--card);border-radius:12px;padding:18px;margin-top:18px;box-shadow:0 6px 24px rgba(0,0,0,0.05)}
    pre{background:#f1f5f9;padding:12px;border-radius:8px;overflow:auto}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    label{font-size:13px;color:var(--muted)}
    input,button,select,textarea{padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.1);background:#f9fafb;color:inherit}
    button{cursor:pointer;background:var(--accent);color:white;border:none}
    button:hover{background:#0369a1}
    .monospace{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
    .status{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:8px}
    .output{background:#f1f5f9;padding:12px;border-radius:8px;overflow-x:auto}
    footer{margin-top:28px;color:var(--muted);font-size:13px;text-align:center}
    .note{background:#e0f2fe;padding:10px;border-radius:8px;color:#0369a1}
    .cite-note{margin-top:8px;font-size:11px;color:#6b7280}
    .back-link{display:inline-block;float:left;margin:16px 0;font-size:16px;color:#0284c7;text-decoration:none;font-weight:500}
    .back-link:hover{text-decoration:underline}
    table{border-collapse:collapse;margin-top:12px;width:100%}
    table, th, td{border:1px solid #ccc}
    th, td{padding:6px;text-align:center}
  </style>
</head>
<body>
  <a href="../snack_break.html" class="back-link">&larr; Back to ðŸ¥¨</a>
  <div class="container">
    <header>
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" aria-hidden>
        <rect x="1" y="1" width="22" height="22" rx="6" fill="#e0f2fe" stroke="#0284c7" stroke-width="0.8"/>
        <path d="M7 12h10M7 8h10M7 16h6" stroke="#0369a1" stroke-width="1.2" stroke-linecap="round"/>
      </svg>
      <div>
        <h1>Homomorphic Encryption â€” Hands-on Intro (Toy LWE)</h1>
        <p class="lead">A short interactive tutorial that demonstrates the core idea of homomorphic encryption using a simple LWE-style toy scheme. This is pedagogical â€” not secure. Use it to learn concepts: keys, encryption, noise growth, and homomorphic addition.</p>
      </div>
    </header>

    <section class="card" id="what-is-fhe">
      <h2>What is FHE (in one sentence)?</h2>
      <p>Fully Homomorphic Encryption (FHE) lets you compute on encrypted data and obtain an encrypted result which, when decrypted, matches the result of performing the same computation on the plaintexts. In practice, FHE schemes are complex â€” this page shows a simplified <em>toy</em> LWE-style construction to build intuition.</p>
    </section>

    <section class="card">
      <h2>Contents</h2>
      <ol>
        <li><a href="#what-is-lwe">What is LWE</a></li>
        <li><a href="#interactive-playground">Interactive playground (using LWE)</a></li>
        <li><a href="#fhe-scheme-diagram">Diagram / timeline of FHE schemes (BFV and CKKS emphasis)</a></li>
        <li><a href="#ckks">CKKS scheme</a></li>
      </ol>
    </section>

    <section class="card" id="what-is-lwe">
      <h2>1. What is LWE</h2>
      <p>The Learning With Errors (LWE) problem is the mathematical foundation of many lattice-based cryptographic schemes, including modern FHE. It is believed to be hard even for quantum computers.</p>
      <p>In LWE, we assume there exists a secret vector \( s \), and we observe many samples of the form:</p>
      <p>\[ (a, b = \langle a, s \rangle + e \bmod q) \]</p>
      <p>where \( a \) is random, and \( e \) is a small noise term. The challenge is to recover \( s \) from these noisy linear equations â€” a problem known to be computationally hard.</p>

      <p>Most FHE schemes build on variants of LWE, such as Ring-LWE (RLWE), where operations take place in polynomial rings for efficiency.</p>

      <h3>Toy scheme (LWE-style) â€” mathematics (short)</h3>
      <p>We define small parameters to illustrate encryption:</p>
      <p>\[ \text{modulus: } q = 97, \quad \text{secret key: } s = 17, \quad \text{noise: } e = \text{small random value (e.g., Â±1)} \]</p>
      <p>To encrypt a message \( m \) with key \( s \):</p>
      <p><em>a</em> â€” random number in the same domain as \( m \)</p>
      <p>\[ Enc(m) = (a, b = (a \cdot s + m + e) \bmod q) \]</p>
      <p>To decrypt using \( s \):</p>
      <p>\[ Dec(a, b) = (b - a \cdot s) \bmod q \approx m + e \]</p>
      <p>Since \( e \) is small, the result is approximately \( m \).</p>
      <p>Homomorphic addition works naturally:</p>
      <p>\[ Enc(m_1) + Enc(m_2) = (a_1 + a_2, b_1 + b_2) \bmod q \;\;\rightarrow\;\; m_1 + m_2 + (e_1 + e_2) \]</p>
      <p>Noise accumulates with operations â€” a key limitation and motivation for advanced schemes like BFV and CKKS.</p>

      <h4>Example: Encrypting and Decrypting a Small Message</h4>
      <p>Encrypt \( m = 5 \) using \( q = 97 \), \( s = 17 \), and \( e = 1 \).</p>
      <ul>
        <li>Choose \( a = 23 \)</li>
        <li>Compute ciphertext: 
          \[ b = (23 \cdot 17 + 5 + 1) \bmod 97 = 12 \]</li>
        <li>Encrypted message: \( Enc(5) = (23, 12) \)</li>
        <li>Decrypt: 
          \[ Dec(23, 12) = (12 - 23 \cdot 17) \bmod 97 = 5 \approx m \]</li>
      </ul>
      <p>Noise is tiny, so decryption recovers the original message.</p>

      <h4>Example: Homomorphic Addition and Noise Accumulation</h4>
      <p>Encrypt two messages \( m_1 = 5 \) and \( m_2 = 7 \):</p>
      <table>
        <thead>
          <tr>
            <th>Message</th>
            <th>Random a</th>
            <th>Noise e</th>
            <th>Ciphertext b = (aÂ·s + m + e) mod q</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>5</td><td>23</td><td>1</td><td>12</td></tr>
          <tr><td>7</td><td>17</td><td>-1</td><td>15</td></tr>
        </tbody>
      </table>
      <p>Homomorphic addition of ciphertexts:</p>
      <p>\[ Enc(m_1) + Enc(m_2) = (23 + 17, 12 + 15) \bmod 97 = (40, 27) \]</p>
      <p>Decrypting the sum:</p>
      <p>\[ Dec(40, 27) = (27 - 40 \cdot 17) \bmod 97 = 12 \approx m_1 + m_2 + (e_1 + e_2) \]</p>
      <p>This shows how noise accumulates and motivates advanced noise management in FHE.</p>
    </section>

    <section class="card" id="interactive-playground">
      <h3>Interactive playground</h3>
      <p>Try encrypting two small integers, add them homomorphically, and decrypt to see how noise behaves.</p>

      <div style="display:flex;gap:12px;flex-wrap:wrap">
        <div style="flex:1;min-width:280px">
          <label>Modulus q (use large to avoid wraparound)</label>
          <input id="q" value="65537" />
        </div>
        <div style="width:160px">
          <label>Secret key s</label>
          <input id="s" readonly class="monospace" />
        </div>
        <div style="width:160px">
          <label>&nbsp;</label>
          <button id="genKey">Generate key</button>
        </div>
      </div>

      <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap">
        <div style="flex:1;min-width:260px">
          <label>Message A (small integer)</label>
          <input id="m1" value="12" />
        </div>
        <div style="flex:1;min-width:260px">
          <label>Message B (small integer)</label>
          <input id="m2" value="7" />
        </div>
        <div style="width:160px">
          <label>Noise stddev</label>
          <input id="noise" value="2" />
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="encA">Encrypt A</button>
        <button id="encB">Encrypt B</button>
        <button id="add">Homomorphic Add (A+B)</button>
        <button id="mulScalar">Scalar Multiply (A * 3)</button>
        <button id="decrypt">Decrypt last result</button>
        <button id="download">Download demo HTML</button>
      </div>

      <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap">
        <div style="flex:1;min-width:260px">
          <div class="output" id="cipherA">Cipher A: â€”</div>
        </div>
        <div style="flex:1;min-width:260px">
          <div class="output" id="cipherB">Cipher B: â€”</div>
        </div>
        <div style="flex:1;min-width:260px">
          <div class="output" id="result">Result: â€”</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <details>
          <summary>Notes about this toy demo</summary>
          <ul>
            <li>Because noise accumulates, repeated operations eventually produce incorrect results.</li>
            <li>Real FHE schemes include relinearization, modulus switching, and bootstrapping to manage noise for deeper circuits.</li>
          </ul>
        </details>
      </div>
    </section>

    <section class="card" id="fhe-scheme-diagram">
      <h2>FHE Scheme Timeline / Diagram</h2>
      <p>Conceptual timeline of popular FHE schemes (simplified):</p>
      <ul>
        <li>Early LWE-based schemes</li>
        <li>BFV (efficient integer arithmetic, supports exact addition/multiplication)</li>
        <li>CKKS (approximate arithmetic for real numbers)</li>
      </ul>
      <p><em>Diagram placeholder â€” insert time-map graphic here</em></p>
    </section>

    <section class="card" id="ckks">
      <h2>CKKS Scheme</h2>
      <p>CKKS is an approximate FHE scheme optimized for real-number arithmetic. Unlike BFV, it encodes numbers as scaled integers and manages approximation errors via rescaling.</p>
      <p>CKKS supports homomorphic addition, multiplication, and batching for efficient vectorized computations.</p>
    </section>

    <footer>
      <p>Educational toy â€” MIT License. Code adapted freely for learning purposes.</p>
      <p class="cite-note">Citations: <br>
        [1] Gentry, C. (2009). A Fully Homomorphic Encryption Scheme. <br>
        [2] Lyubashevsky, V., Peikert, C., & Regev, O. (2013). Lattice-based Cryptography.
      </p>
    </footer>
  </div>

  <script>
  let secretKey = null;
  let cipherA = null;
  let cipherB = null;
  let lastResult = null;

  function mod(n, q) {
    return ((n % q) + q) % q;
  }

  document.getElementById('genKey').addEventListener('click', () => {
    const q = parseInt(document.getElementById('q').value);
    secretKey = Math.floor(Math.random() * q);
    document.getElementById('s').value = secretKey;
    cipherA = cipherB = lastResult = null;
    document.getElementById('cipherA').textContent = "Cipher A: â€”";
    document.getElementById('cipherB').textContent = "Cipher B: â€”";
    document.getElementById('result').textContent = "Result: â€”";
  });

  document.getElementById('encA').addEventListener('click', () => {
    const q = parseInt(document.getElementById('q').value);
    const m1 = parseInt(document.getElementById('m1').value);
    const e = parseInt(document.getElementById('noise').value);
    const a = Math.floor(Math.random() * q);
    cipherA = { a: a, b: mod(a * secretKey + m1 + e, q) };
    document.getElementById('cipherA').textContent = `Cipher A: (${cipherA.a}, ${cipherA.b})`;
    lastResult = null;
    document.getElementById('result').textContent = "Result: â€”";
  });

  document.getElementById('encB').addEventListener('click', () => {
    const q = parseInt(document.getElementById('q').value);
    const m2 = parseInt(document.getElementById('m2').value);
    const e = parseInt(document.getElementById('noise').value);
    const a = Math.floor(Math.random() * q);
    cipherB = { a: a, b: mod(a * secretKey + m2 + e, q) };
    document.getElementById('cipherB').textContent = `Cipher B: (${cipherB.a}, ${cipherB.b})`;
    lastResult = null;
    document.getElementById('result').textContent = "Result: â€”";
  });

  document.getElementById('add').addEventListener('click', () => {
    if(!cipherA || !cipherB) { alert("Encrypt A and B first!"); return; }
    const q = parseInt(document.getElementById('q').value);
    lastResult = { a: mod(cipherA.a + cipherB.a, q), b: mod(cipherA.b + cipherB.b, q) };
    document.getElementById('result').textContent = `Result: (${lastResult.a}, ${lastResult.b})`;
  });

  document.getElementById('mulScalar').addEventListener('click', () => {
    if(!cipherA) { alert("Encrypt A first!"); return; }
    const q = parseInt(document.getElementById('q').value);
    const scalar = 3;
    lastResult = { a: mod(cipherA.a * scalar, q), b: mod(cipherA.b * scalar, q) };
    document.getElementById('result').textContent = `Result: (${lastResult.a}, ${lastResult.b})`;
  });

  document.getElementById('decrypt').addEventListener('click', () => {
    if(!lastResult) { alert("Perform an operation first!"); return; }
    const q = parseInt(document.getElementById('q').value);
    const dec = mod(lastResult.b - lastResult.a * secretKey, q);
    alert(`Decrypted result: ${dec}`);
  });

  document.getElementById('download').addEventListener('click', () => {
    const blob = new Blob([document.documentElement.outerHTML], {type: "text/html"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "fhe_toy_demo.html";
    a.click();
    URL.revokeObjectURL(url);
  });
</script>

</body>
</html>
