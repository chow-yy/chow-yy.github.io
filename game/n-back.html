<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>N-back Brain Game</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* --- MODIFIED --- */
  /* Moved inline styles here and set up the flex layout */
  #game-container {
    display: flex;
    flex-wrap: wrap; /* Allows items to wrap on small screens */
    justify-content: center;
    gap: 20px;
    width: 100%;
  }

  #grid-container {
    display: flex;
    justify-content: center;
    margin: 20px 0;
  }

  #grid {
    display: grid;
    gap: 5px;
  }

  .cell {
    width: 50px;
    height: 50px;
    background-color: lightgray;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    border-radius: 5px;
    user-select: none;
    transition: background-color 0.3s;
  }

  .active {
    background-color: blue;
    color: white;
  }

  .matched {
    background-color: green !important;
    color: white;
  }

  button {
    margin-top: 20px;
    font-size: 16px;
    padding: 10px 20px;
  }

  /* --- MODIFIED --- */
  #instruction {
    /* REMOVED: position: absolute; */
    /* REMOVED: top: 0; */
    /* REMOVED: right: 0; */
    
    /* Added styles from your inline HTML */
    max-width: 250px;
    background-color: #f0f0f0;
    padding: 10px;
    border-radius: 5px;
    font-size: 14px;
    
    /* Added this to stop it from stretching vertically */
    height: fit-content; 
  }

  label {
    margin: 0 10px;
  }
</style>
</head>
<body>
<a href="../game.html" class="back-link">&larr; Back to ðŸ¥¨</a>

<h1>N-back Brain Training</h1>

<div id="game-container">
    <div id="instruction">
        Watch the sequence of blue squares.<br>
        Click <strong>Match</strong> if it matches the one <span id="nDisplay">N</span> steps back.<br>
        Find 5 matches to finish.
    </div>

    <div style="display:flex; flex-direction:column; align-items:center;">
        <div>
            <label>Grid size (L): <input type="number" id="gridSize" value="3" min="2" max="6"></label>
            <label>N-back (N): <input type="number" id="nBack" value="2" min="1"></label>
            <button onclick="startGame()">Start Game</button>
        </div>

        <div>
            <label>Speed (ms): <span id="speedDisplay">1500</span></label>
            <input type="range" id="speedSlider" min="500" max="3000" step="100" value="1500" oninput="updateSpeed(this.value)">
        </div>

        <div id="grid-container">
            <div id="grid"></div>
        </div>

        <button id="matchBtn" disabled onclick="matchClicked()">Match</button>
        <h2 id="result"></h2>
    </div>
</div>

<script>
let DISPLAY_INTERVAL = 1500;
let TOTAL_MATCHES = 5;

let L, N;
let sequence = [];
let matchPositions = [];
let currentIndex = 0;
let userMatches = [];
let interval;

function updateSpeed(value) {
    DISPLAY_INTERVAL = parseInt(value);
    document.getElementById('speedDisplay').textContent = DISPLAY_INTERVAL;

    if(interval) {
        clearInterval(interval);
        interval = setInterval(showNext, DISPLAY_INTERVAL);
    }
}

function startGame() {
    L = parseInt(document.getElementById('gridSize').value);
    N = parseInt(document.getElementById('nBack').value);

    // Update N display in instructions
    document.getElementById('nDisplay').textContent = N;

    generateSequence();
    createGrid();
    currentIndex = 0;
    userMatches = [];
    document.getElementById('result').textContent = '';
    document.getElementById('matchBtn').disabled = false;

    // Disable controls during game
    document.getElementById('gridSize').disabled = true;
    document.getElementById('nBack').disabled = true;
    document.querySelector('button[onclick="startGame()"]').disabled = true;

    interval = setInterval(showNext, DISPLAY_INTERVAL);
}

function generateSequence() {
    sequence = [];
    matchPositions = [];
    let nonMatchCount = 0;
    let totalAttempts = 0;
    const maxAttempts = (L*L) * 10; // Safety break
    const targetLength = Math.max(20, TOTAL_MATCHES * (N + 2)); // Ensure a reasonable sequence length

    while (sequence.length < targetLength && totalAttempts < maxAttempts) {
        let rand = Math.floor(Math.random() * (L * L));
        sequence.push(rand);
        totalAttempts++;

        if (sequence.length > N) {
            if (sequence[sequence.length - 1] === sequence[sequence.length - N - 1]) {
                // This is a match
                if (!matchPositions.includes(sequence.length - 1)) {
                    matchPositions.push(sequence.length - 1);
                }
            } else {
                nonMatchCount++;
            }
        }
    }
    
    // If not enough matches, add them
    while (matchPositions.length < TOTAL_MATCHES && sequence.length < maxAttempts) {
        let prevIndex = sequence.length - N;
        if (prevIndex >= 0) {
             sequence.push(sequence[prevIndex]); // Force a match
             matchPositions.push(sequence.length - 1);
        } else {
            // Need more items before a match is possible
             sequence.push(Math.floor(Math.random() * (L * L)));
        }
        
        // Add some non-matches
        for(let i=0; i<N; i++) {
            let rand;
            let prev = sequence[sequence.length-N];
            do {
                 rand = Math.floor(Math.random() * (L * L));
            } while (rand === prev); // Ensure it's not a match
            sequence.push(rand);
        }
    }

    console.log("Sequence:", sequence);
    console.log("Match positions:", matchPositions);
}

function createGrid() {
    const grid = document.getElementById('grid');
    grid.innerHTML = '';
    grid.style.gridTemplateColumns = `repeat(${L}, 50px)`;
    grid.style.gridTemplateRows = `repeat(${L}, 50px)`;

    for(let i = 0; i < L*L; i++) {
        let cell = document.createElement('div');
        cell.className = 'cell';
        cell.id = 'cell-' + i;
        // cell.textContent = i; // Hiding the number for a cleaner look
        grid.appendChild(cell);
    }
}

function showNext() {
    if(currentIndex > 0 && sequence[currentIndex-1] !== undefined) {
         const prevCell = document.getElementById('cell-' + sequence[currentIndex-1]);
         if (prevCell) prevCell.classList.remove('active');
    }

    if(currentIndex >= sequence.length) {
        clearInterval(interval);
        interval = null;
        document.getElementById('matchBtn').disabled = true;
        
        // Re-enable controls
        document.getElementById('gridSize').disabled = false;
        document.getElementById('nBack').disabled = false;
        document.querySelector('button[onclick="startGame()"]').disabled = false;

        calculateAccuracy();
        return;
    }

    const nextCell = document.getElementById('cell-' + sequence[currentIndex]);
    if (nextCell) {
        nextCell.classList.add('active');
    }
    currentIndex++;
}

function matchClicked() {
    if (currentIndex > 0) {
        userMatches.push(currentIndex - 1);
    }
}

function calculateAccuracy() {
    let correctClicks = 0;
    
    // Use a Set for efficient lookup
    const userMatchSet = new Set(userMatches);
    const actualMatchSet = new Set(matchPositions);

    // Count correct clicks
    for(let pos of userMatchSet) {
        if(actualMatchSet.has(pos)) {
            correctClicks++;
        }
    }

    // Count missed matches
    let missed = 0;
    for(let pos of actualMatchSet) {
        if(!userMatchSet.has(pos)) {
            missed++;
        }
    }

    // Count false positives (wrong clicks)
    let falsePositives = 0;
    for(let pos of userMatchSet) {
        if(!actualMatchSet.has(pos)) {
            falsePositives++;
        }
    }

    let accuracy = actualMatchSet.size > 0 ? (correctClicks / actualMatchSet.size) * 100 : 0;
    if (userMatchSet.size === 0 && actualMatchSet.size === 0) accuracy = 100; // No matches expected, none clicked

    document.getElementById('result').textContent =
        `Found: ${correctClicks}/${actualMatchSet.size} | Missed: ${missed} | Wrong Clicks: ${falsePositives}`;

    // Highlight actual matched positions
    matchPositions.forEach(pos => {
        if (sequence[pos] !== undefined) {
            const cell = document.getElementById('cell-' + sequence[pos]);
            if (cell) cell.classList.add('matched');
        }
    });

    setTimeout(() => {
        matchPositions.forEach(pos => {
             if (sequence[pos] !== undefined) {
                const cell = document.getElementById('cell-' + sequence[pos]);
                if (cell) cell.classList.remove('matched');
             }
        });
    }, 2000);
}

// Also update N display on load
document.getElementById('nDisplay').textContent = document.getElementById('nBack').value;

</script>

</body>
</html>
