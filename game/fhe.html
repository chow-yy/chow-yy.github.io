<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Intro to FHE — Interactive Tutorial</title>
  <style>
    :root{--bg:#f9fafb;--card:#ffffff;--muted:#4b5563;--accent:#0284c7}
    body{font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#f0f9ff 0%,#ffffff 100%);color:#111827;margin:0;padding:32px}
    .container{max-width:980px;margin:0 auto}
    header{display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:28px}
    p.lead{color:var(--muted);margin-top:8px}
    .card{background:var(--card);border-radius:12px;padding:18px;margin-top:18px;box-shadow:0 6px 24px rgba(0,0,0,0.05)}
    pre{background:#f1f5f9;padding:12px;border-radius:8px;overflow:auto}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    .controls{display:flex;flex-direction:column;gap:8px}
    label{font-size:13px;color:var(--muted)}
    input,button,select,textarea{padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.1);background:#f9fafb;color:inherit}
    button{cursor:pointer;background:var(--accent);color:white;border:none}
    button:hover{background:#0369a1}
    .monospace{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
    .status{font-size:13px;color:var(--muted)}
    .row{display:flex;gap:8px}
    .output{background:#f1f5f9;padding:12px;border-radius:8px}
    footer{margin-top:28px;color:var(--muted);font-size:13px}
    .note{background:#e0f2fe;padding:10px;border-radius:8px;color:#0369a1}
    .kbd{background:#e5e7eb;padding:2px 6px;border-radius:6px;border:1px solid rgba(0,0,0,0.1)}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" aria-hidden>
        <rect x="1" y="1" width="22" height="22" rx="6" fill="#e0f2fe" stroke="#0284c7" stroke-width="0.8"/>
        <path d="M7 12h10M7 8h10M7 16h6" stroke="#0369a1" stroke-width="1.2" stroke-linecap="round"/>
      </svg>
      <div>
        <h1>Homomorphic Encryption — Hands-on Intro (Toy LWE)</h1>
        <p class="lead">A short interactive tutorial that demonstrates the core idea of homomorphic encryption using a simple LWE-style toy scheme. This is pedagogical — not secure. Use it to learn concepts: keys, encryption, noise growth, and homomorphic addition.</p>
      </div>
    </header>

        <section class="card">
      <h2>What is FHE (in one sentence)?</h2>
      <p>Fully Homomorphic Encryption (FHE) lets you compute on encrypted data and obtain an encrypted result which, when decrypted, matches the result of performing the same computation on the plaintexts. In practice, FHE schemes are complex — this page shows a simplified <em>toy</em> LWE-style construction to build intuition.</p>
    </section>

    <div class="grid">
      <main>
        <section class="card">
          <h3>Core concepts</h3>
          <ul>
            <li><strong>Secret key:</strong> kept private by the decryptor.</li>
            <li><strong>Encryption:</strong> hides the message but allows algebraic operations to be performed on ciphertexts.</li>
            <li><strong>Noise:</strong> small random error introduced at encryption — noise grows with operations and limits how many operations you can do.</li>
            <li><strong>Homomorphic addition (easy):</strong> add two ciphertexts to get ciphertext of sum.</li>
            <li><strong>Homomorphic multiplication (hard):</strong> supported but increases noise fast; real schemes use relinearization/rescaling.</li>
          </ul>
          <div class="note">
            This tutorial uses a toy LWE-style scheme with ciphertexts represented as pairs (a, b). It demonstrates addition and scalar multiplication and visualizes noise growth.
          </div>
        </section>

        <section class="card">
          <h3>Toy scheme (LWE-style) — mathematics (short)</h3>
          <p class="monospace">Keys: choose modulus <code>q</code> (large), secret key <code>s &lt; q</code> random.</p>
          <p class="monospace">Encrypt message <code>m</code> (small integer): pick random <code>a</code> &lt;&lt; q and small noise <code>e</code>. Set</p>
          <pre class="monospace">b = (a*s + m + e) mod q
ciphertext = (a, b)</pre>
          <p>Decrypt: compute <code>(b - a*s) mod q</code>. That equals <code>m + e</code> (mod q). If the noise <code>e</code> is small enough we can recover <code>m</code> by rounding to the nearest integer.</p>

          <p><strong>Homomorphic addition:</strong> add components element-wise: <code>(a1+a2, b1+b2)</code>. The decrypted value becomes <code>(m1 + m2) + (e1 + e2)</code>, so noise adds.</p>

          <p><strong>Scalar multiply:</strong> multiply both components by scalar <code>c</code>: ciphertext scales and noise scales by <code>c</code>.</p>

          <p><strong>Note:</strong> Real FHE schemes support efficient multiplication, key switching and noise management; this page only demonstrates the intuition.</p>
        </section>

        <section class="card">
          <h3>Interactive playground</h3>
          <p>Try encrypting two small integers, add them homomorphically, and decrypt to see how noise behaves.</p>

          <div style="display:flex;gap:12px;flex-wrap:wrap">
            <div style="flex:1;min-width:280px">
              <label>Modulus q (use large to avoid wraparound)</label>
              <input id="q" value="65537" />
            </div>
            <div style="width:160px">
              <label>Secret key s</label>
              <input id="s" readonly class="monospace" />
            </div>
            <div style="width:160px">
              <label>&nbsp;</label>
              <button id="genKey">Generate key</button>
            </div>
          </div>

          <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap">
            <div style="flex:1;min-width:260px">
              <label>Message A (small integer)</label>
              <input id="m1" value="12" />
            </div>
            <div style="flex:1;min-width:260px">
              <label>Message B (small integer)</label>
              <input id="m2" value="7" />
            </div>
            <div style="width:160px">
              <label>Noise stddev</label>
              <input id="noise" value="2" />
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button id="encA">Encrypt A</button>
            <button id="encB">Encrypt B</button>
            <button id="add">Homomorphic Add (A+B)</button>
            <button id="mulScalar">Scalar Multiply (A * 3)</button>
            <button id="decrypt">Decrypt last result</button>
            <button id="download">Download demo HTML</button>
          </div>

          <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap">
            <div style="flex:1;min-width:260px">
              <div class="output" id="cipherA">Cipher A: —</div>
            </div>
            <div style="flex:1;min-width:260px">
              <div class="output" id="cipherB">Cipher B: —</div>
            </div>
            <div style="flex:1;min-width:260px">
              <div class="output" id="result">Result: —</div>
            </div>
          </div>

          <div style="margin-top:12px">
            <details>
              <summary>Notes about this toy demo</summary>
              <ul>
                <li>Because noise accumulates, if you repeatedly add or multiply ciphertexts the decrypted value will eventually be wrong.</li>
                <li>Real FHE schemes include operations (relinearization, modulus switching, bootstrapping) to manage noise and permit deep circuits.</li>
              </ul>
            </details>
          </div>
        </section>

        <section class="card">
          <h3>Further reading (recommended next steps)</h3>
          <ol>
            <li>Learn LWE/LWR and RLWE foundations — these are the hardness assumptions behind modern FHE.</li>
            <li>Study concrete schemes: BFV (integer arithmetic), CKKS (approximate real arithmetic).</li>
            <li>Explore libraries: Microsoft SEAL, PALISADE, HElib — they implement practical, well-tested FHE.</li>
          </ol>
        </section>

      </main>

      <aside>
        <div class="card">
          <h4>Live status</h4>
          <div class="status">Secret key: <span id="status-s">(none)</span></div>
          <div class="status">Last decrypt: <span id="status-decrypt">—</span></div>
          <hr />
          <h4>How to use</h4>
          <ol>
            <li>Generate a key or paste your own modulus &amp; secret key.</li>
            <li>Enter two small integers &amp; noise level and encrypt them.</li>
            <li>Try homomorphic addition and then decrypt to see the sum.</li>
          </ol>
          <hr />
          <div class="note">
            <strong>Important:</strong> This demo is educational only. It is <em>not</em> secure and should not be used for real data or production systems.
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h4>Explainer — why noise matters</h4>
          <p class="status">Each encryption adds a small random error. Operations on ciphertexts combine those errors; eventually the error can overwhelm the message and decryption fails. Bootstrapping resets noise but is expensive — a major technical achievement in FHE research.</p>
        </div>
      </aside>
    </div>

    <footer>
      <div class="card">
        <strong>Credits</strong>
        <p class="status">Author: Interactive tutorial generator — educational toy. License: MIT (adapt freely).</p>
      </div>
    </footer>
  </div>

  <script>
    // --- small BigInt helper functions ---
    function toBigInt(n){ try { return BigInt(n); } catch(e){ return BigInt(parseInt(n,10) || 0); } }
    function randBetween(max){ // 0..max-1
      max = BigInt(max);
      return BigInt(Math.floor(Math.random()*Number(max)));
    }

    // reduce to signed range [-q/2, q/2)
    function signedMod(x, q){ x = ((x % q) + q) % q; const half = q/2n; if (x >= half) return x - q; return x; }

    // generate small noise from gaussian-like approx (sum of uniforms)
    function sampleNoise(stddev){ const n=6; let sum=0; for(let i=0;i<n;i++) sum += (Math.random()-0.5); return Math.round(sum * stddev * 2); }

    // toy LWE-type scheme operations
    let state = { q: 65537n, s: null, lastCipher: null };

    function genKey(){ const q = toBigInt(document.getElementById('q').value || 65537); state.q = q; state.s = randBetween(q); document.getElementById('s').value = state.s.toString(); document.getElementById('status-s').textContent = state.s.toString(); }

    function encryptMessage(m, noiseStd){ // returns {a:BigInt, b:BigInt, noise:Int}
      const q = state.q; const a = randBetween(q); const e = BigInt(sampleNoise(noiseStd)); const b = (a * state.s + BigInt(m) + e) % q; return {a,b,noise:e}; }

    function decryptCipher(ct){ const q = state.q; const a = ct.a; const b = ct.b; const plainWithNoise = signedMod(b - a * state.s, q); // this equals m + e in signed range
      return {value: Number(plainWithNoise), noise: Number(signedMod(plainWithNoise - BigInt(ct.plain || 0), q))}; }

    function addCipher(c1, c2){ return {a: (c1.a + c2.a) % state.q, b: (c1.b + c2.b) % state.q}; }

    function scalarMul(c, scalar){ const sc = BigInt(scalar); return {a: (c.a * sc) % state.q, b: (c.b * sc) % state.q}; }

    // UI wiring
    document.getElementById('genKey').addEventListener('click', ()=>{ genKey(); });

    document.getElementById('encA').addEventListener('click', ()=>{
      if (!state.s){ genKey(); }
      const m = parseInt(document.getElementById('m1').value || '0',10);
      const noiseStd = parseFloat(document.getElementById('noise').value || '2');
      const ct = encryptMessage(m, noiseStd); ct.plain = m; state.cipherA = ct; state.lastCipher = ct;
      document.getElementById('cipherA').textContent = `a=${ct.a.toString()}\nb=${ct.b.toString()}\n(plaintext=${m}, noise≈${ct.noise})`;
      document.getElementById('status-decrypt').textContent = 'Encrypted A';
    });

    document.getElementById('encB').addEventListener('click', ()=>{
      if (!state.s){ genKey(); }
      const m = parseInt(document.getElementById('m2').value || '0',10);
      const noiseStd = parseFloat(document.getElementById('noise').value || '2');
      const ct = encryptMessage(m, noiseStd); ct.plain = m; state.cipherB = ct; state.lastCipher = ct;
      document.getElementById('cipherB').textContent = `a=${ct.a.toString()}\nb=${ct.b.toString()}\n(plaintext=${m}, noise≈${ct.noise})`;
      document.getElementById('status-decrypt').textContent = 'Encrypted B';
    });

    document.getElementById('add').addEventListener('click', ()=>{
      if (!state.cipherA || !state.cipherB){ alert('Encrypt both A and B first'); return; }
      const res = addCipher(state.cipherA, state.cipherB); res.plain = (state.cipherA.plain + state.cipherB.plain);
      state.lastCipher = res;
      document.getElementById('result').textContent = `a=${res.a.toString()}\nb=${res.b.toString()}\n(plaintext sum=${res.plain}, noise≈(e1+e2) )`;
      document.getElementById('status-decrypt').textContent = 'Added A + B (ciphertext)';
    });

    document.getElementById('mulScalar').addEventListener('click', ()=>{
      if (!state.lastCipher){ alert('Encrypt something first'); return; }
      const res = scalarMul(state.lastCipher, 3);
      res.plain = state.lastCipher.plain * 3;
      state.lastCipher = res;
      document.getElementById('result').textContent = `a=${res.a.toString()}\nb=${res.b.toString()}\n(plaintext scaled=${res.plain}, noise scaled)`;
      document.getElementById('status-decrypt').textContent = 'Scalar multiplied last ciphertext by 3';
    });

    document.getElementById('decrypt').addEventListener('click', ()=>{
      if (!state.lastCipher){ alert('No ciphertext to decrypt'); return; }
      const ct = state.lastCipher;
      const dec = decryptCipher(ct);
      document.getElementById('result').textContent = `Decrypted ≈ ${dec.value} (expected ${ct.plain})\nNoise presence means value may differ from exact plaintext when noise is large.`;
      document.getElementById('status-decrypt').textContent = `Last decrypt: ${dec.value} (expected ${ct.plain})`;
    });

    // download the HTML file (self-contained)
    document.getElementById('download').addEventListener('click', ()=>{
      const blob = new Blob([document.documentElement.outerHTML], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'fhe_toy_demo.html'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });
    // initialize
    genKey();
  </script>
  </div>
</body>
</html>
